<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux命令</title>
    <link href="/2020/11/03/Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/11/03/Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux基本命令"><a href="#Linux基本命令" class="headerlink" title="Linux基本命令"></a><strong>Linux</strong>基本命令</h1><h2 id="Linux的简介"><a href="#Linux的简介" class="headerlink" title="Linux的简介"></a><strong>Linux</strong>的简介</h2><p>Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。</p><p>Linux操作系统诞生于1991 年10 月5 日（这是第一次正式向外公布时间）。Linux存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。</p><h1 id="一、文件操作基本命令"><a href="#一、文件操作基本命令" class="headerlink" title="一、文件操作基本命令"></a>一、文件操作基本命令</h1><h3 id="1、ls命令-显示文件"><a href="#1、ls命令-显示文件" class="headerlink" title="1、ls命令(显示文件)"></a><strong>1、ls</strong>命令(显示文件)</h3><ul><li>ls命令的功能是显示指定目录下的<strong>文件目录清单</strong>相当于dos下的dir命令，而且其参数更加丰富多样。</li></ul><h5 id="1-1-ls不带参数"><a href="#1-1-ls不带参数" class="headerlink" title="1.1 ls不带参数"></a>1.1 ls不带参数</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ls</span><span class="hljs-meta">anaconda-ks.cfg</span> <span class="hljs-string">install.log install.log.syslog</span></code></pre><p>功能：显示指定目录中的文件清单，如果没有指定任何目录，则默认为当前目录。</p><h5 id="1-2-显示隐藏文件"><a href="#1-2-显示隐藏文件" class="headerlink" title="1.2 显示隐藏文件"></a><strong>1.2 显示隐藏文件</strong></h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ls -a</span><span class="hljs-meta">anaconda-ks.cfg</span> <span class="hljs-string">.bash_logout  .bashrc install.log     .tcshrc</span><span class="hljs-attr">bash_history</span>  <span class="hljs-string">.bash_profile .cshrc  install.log.syslog</span></code></pre><p><strong>参数</strong> <strong>-a</strong> 的功能：显示隐含文件。</p><p>说明：若文件名*<strong>以“.”开头，则认为是隐含的</strong>，进而普通的ls命令不显示以“.”开头的文件；所以要完全显示某目录下的文件清单，必须加上-a参数才行。</p><h5 id="1-3-长格式输出"><a href="#1-3-长格式输出" class="headerlink" title="1.3 长格式输出"></a><strong>1.3 长格式输出</strong></h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ls -l</span><span class="hljs-meta">总用量</span> <span class="hljs-string">24</span><span class="hljs-meta">-rw-------.</span> <span class="hljs-string">1 root root  1116 11月 13 18:15 anaconda-ks.cfg</span><span class="hljs-meta">-rw-r--r--.</span> <span class="hljs-string">1 root root 12526 11月 13 18:15 install.log</span><span class="hljs-meta">-rw-r--r--.</span> <span class="hljs-string">1 root root  3482 11月 13 18:14 install.log.syslog</span></code></pre><pre><code class="hljs properties"><span class="hljs-meta">参数-l</span> <span class="hljs-string">的功能是：以长格式列表输出指定目录中的文件清单</span><span class="hljs-attr">以上述输出中文件install.log为例</span> <span class="hljs-attr">解释长格式输出的内容如下：</span><span class="hljs-meta">文件权限</span>       <span class="hljs-string">连接数  属主    属组    大小    日期     时间      文件名</span><span class="hljs-meta">-rw-r--r--.</span>    <span class="hljs-string">1    root   root   12526   11月13 18:15   install.log</span><span class="hljs-attr">Linux文件有三种典型的权限，即r读权限、w写权限和x执行权限。在长格式输出中在文件类型的后面有9列权限位，实际上这是针对不同用户而设定的，如下所示。</span><span class="hljs-meta">属主的权限</span>  <span class="hljs-string">属组的权限  其他用户的权限</span>  <span class="hljs-attr">rwx</span>       <span class="hljs-string">rwx         r-x</span></code></pre><h5 id="1-4-递归显示"><a href="#1-4-递归显示" class="headerlink" title="1.4 递归显示"></a><strong>1.4 递归显示</strong></h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ls -R</span><span class="hljs-attr">..</span><span class="hljs-meta">anaconda-ks.cfg</span>  <span class="hljs-string">install.log  install.log.syslog</span><span class="hljs-meta">参数-R</span> <span class="hljs-string">的功能是：递归显示指定目录下的文件清单，</span><span class="hljs-attr">即会显示指定目录分支内各子目录中的文件清单。</span></code></pre><h3 id="2、pwd命令（显示当前目录）"><a href="#2、pwd命令（显示当前目录）" class="headerlink" title="2、pwd命令（显示当前目录）"></a>2、pwd命令（显示当前目录）</h3><pre><code class="hljs properties"><span class="hljs-attr">示例：pwd</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# pwd</span><span class="hljs-attr">/root</span><span class="hljs-attr">功能：显示当前目录。</span></code></pre><h3 id="3、mkdir命令（创建目录）"><a href="#3、mkdir命令（创建目录）" class="headerlink" title="3、mkdir命令（创建目录）"></a>3、mkdir命令（创建目录）</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）mkdir示例一</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# mkdir abc</span><span class="hljs-attr">功能：在当前目录下创建目录abc</span><span class="hljs-attr">（2）mkdir示例二——创建多级目录</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# mkdir -p a/b/c</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ls -R a</span><span class="hljs-attr">a</span>:<span class="hljs-string"></span><span class="hljs-attr">b</span><span class="hljs-meta">a/b</span>:<span class="hljs-string"></span><span class="hljs-attr">c</span><span class="hljs-meta">a/b/c</span>:<span class="hljs-string">功能：参数-p功能是如果要创建的目录的父目录不存在，则先创建其父目录，再创建该目录； 如果指定的目录存在，则不影响原目录，也不会报错。在本示例中会连续创建a目录、a/b目录、a/b/c目录。</span></code></pre><h3 id="4、cd命令"><a href="#4、cd命令" class="headerlink" title="4、cd命令"></a>4、cd命令</h3><pre><code class="hljs properties"><span class="hljs-attr">cd</span> <span class="hljs-string">XX 进入目录</span><span class="hljs-attr">cd</span> <span class="hljs-string">.. 返回上一级目录</span><span class="hljs-attr">cd</span> <span class="hljs-string">/  进入根目录</span><span class="hljs-attr">cd</span> <span class="hljs-string">../..返回上一级目录的上一级目录</span></code></pre><h3 id="5、touch命令（创建空文件）"><a href="#5、touch命令（创建空文件）" class="headerlink" title="5、touch命令（创建空文件）"></a>5、touch命令（创建空文件）</h3><h5 id="5-1-创建空文件"><a href="#5-1-创建空文件" class="headerlink" title="5.1 创建空文件"></a>5.1 创建空文件</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# touch myfile</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ls -l myfile</span><span class="hljs-meta">-rw-r--r--.</span> <span class="hljs-string">1 root root 0 11月 13 23:48 myfile</span><span class="hljs-attr">功能：如果myfile不存在，则创建一个大小为0字节名为myfile的空文件。</span></code></pre><h5 id="5-2-改变文件的最后修改时间"><a href="#5-2-改变文件的最后修改时间" class="headerlink" title="5.2 改变文件的最后修改时间"></a>5.2 改变文件的最后修改时间</h5><pre><code class="hljs properties"><span class="hljs-meta">再执行一次touch</span> <span class="hljs-string">myfile</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# touch myfile</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ls -l myfile</span><span class="hljs-meta">-rw-r--r--.</span> <span class="hljs-string">1 root root 0 11月 13 23:49 myfile</span><span class="hljs-attr">功能：如果myfile已存在，则将改变myfile的最后修改时间。</span></code></pre><h3 id="6、cp命令（复制）"><a href="#6、cp命令（复制）" class="headerlink" title="6、cp命令（复制）"></a>6、cp命令（复制）</h3><h5 id="6-1-复制文件"><a href="#6-1-复制文件" class="headerlink" title="6.1 复制文件"></a>6.1 复制文件</h5><pre><code class="hljs properties"><span class="hljs-attr">（1）cp示例一——复制文件</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# cp /etc/*   abc</span><span class="hljs-attr">功能：将/etc/目录下的文件复制到目录abc中。“*”是通配符，可以匹配多个字符；“？”只能匹配一个字符。</span></code></pre><h5 id="6-2-复制目录"><a href="#6-2-复制目录" class="headerlink" title="6.2 复制目录"></a>6.2 复制目录</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# cp  -R   /etc  abc</span><span class="hljs-attr">功能：增加了参数-Ｒ，就能将目录/etc下面的所有子目录和文件都复制到目录abc中。</span></code></pre><h3 id="7、mv命令（移动，改名）"><a href="#7、mv命令（移动，改名）" class="headerlink" title="7、mv命令（移动，改名）"></a>7、mv命令（移动，改名）</h3><h5 id="7-1-将文件移动到目录中"><a href="#7-1-将文件移动到目录中" class="headerlink" title="7.1 将文件移动到目录中"></a>7.1 将文件移动到目录中</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# mv  myfile  mydir1</span><span class="hljs-attr">功能：如果mydir1存在且是个目录，则将文件myfile移动到目录mydir1中。</span></code></pre><h5 id="7-2-文件改名"><a href="#7-2-文件改名" class="headerlink" title="7.2 文件改名"></a>7.2 文件改名</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# mv myfile myfile2</span><span class="hljs-attr">功能：将文件（或目录）myfile改名为myfile2。</span></code></pre><h3 id="8、rmdir命令（删除空目录）"><a href="#8、rmdir命令（删除空目录）" class="headerlink" title="8、rmdir命令（删除空目录）"></a>8、rmdir命令（删除空目录）</h3><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# rmdir   mydir1</span><span class="hljs-attr">功能：删除指定的空目录。</span></code></pre><h3 id="9、rm命令（删除文件）"><a href="#9、rm命令（删除文件）" class="headerlink" title="9、rm命令（删除文件）"></a>9、rm命令（删除文件）</h3><h5 id="9-1-删除文件"><a href="#9-1-删除文件" class="headerlink" title="9.1 删除文件"></a>9.1 删除文件</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# rm  php.ini</span><span class="hljs-meta">功能：删除指定的文件</span> <span class="hljs-string">php.ini。</span></code></pre><h5 id="9-2-删除目录"><a href="#9-2-删除目录" class="headerlink" title="9.2 删除目录"></a>9.2 删除目录</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# rm  -rf  abc</span><span class="hljs-attr">功能：参数-r是递归的意思，即可以删除非空目录；参数-f是强制的意思。</span></code></pre><h3 id="10、cat命令（显示文件内容）"><a href="#10、cat命令（显示文件内容）" class="headerlink" title="10、cat命令（显示文件内容）"></a>10、cat命令（显示文件内容）</h3><h5 id="10-1-显示文件内容"><a href="#10-1-显示文件内容" class="headerlink" title="10.1 显示文件内容"></a>10.1 显示文件内容</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# cat myfile</span><span class="hljs-attr">hello,world</span><span class="hljs-attr">功能：显示指定文件myfile的内容。</span></code></pre><h5 id="10-2-创建文件"><a href="#10-2-创建文件" class="headerlink" title="10.2 创建文件"></a>10.2 创建文件</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# cat  &gt;  myfile2</span><span class="hljs-attr">Welcome</span> <span class="hljs-string">to Linux World!</span><span class="hljs-attr">按ctrl+d结束输入</span><span class="hljs-attr">功能：利用输出重定向符“&gt;”来创建简短的文本文件myfile2。</span></code></pre><h3 id="11、more-和-less命令（分屏显示文件内容）"><a href="#11、more-和-less命令（分屏显示文件内容）" class="headerlink" title="11、more 和 less命令（分屏显示文件内容）"></a>11、more 和 less命令（分屏显示文件内容）</h3><pre><code class="hljs properties"><span class="hljs-comment"># more  /etc/httpd/conf/httpd.conf</span><span class="hljs-attr">功能：分屏显示指定文件httpd.conf的内容，非常适合显示超过一屏的文本文件。每按一下空格键，向后翻一屏；每按一次回车键，向后翻一行。</span><span class="hljs-attr">说明：less与more功能很相似，只不过less功能更强大，支持PageUp键向前翻屏，及PageDown向后翻屏。</span></code></pre><h3 id="12、head命令（显示文件前面内容）"><a href="#12、head命令（显示文件前面内容）" class="headerlink" title="12、head命令（显示文件前面内容）"></a>12、head命令（显示文件前面内容）</h3><h5 id="12-1-显示文件头10行内容"><a href="#12-1-显示文件头10行内容" class="headerlink" title="12.1 显示文件头10行内容"></a>12.1 显示文件头10行内容</h5><pre><code class="hljs properties"><span class="hljs-comment"># head  /etc/httpd/conf/httpd.conf</span><span class="hljs-attr">功能：默认显示指定文件的头10行的内容。</span></code></pre><h5 id="12-2-显示文件头n行内容"><a href="#12-2-显示文件头n行内容" class="headerlink" title="12.2 显示文件头n行内容"></a>12.2 显示文件头n行内容</h5><pre><code class="hljs properties"><span class="hljs-comment"># head -n 19 /etc/httpd/conf/httpd.conf</span><span class="hljs-attr">功能：参数-n设置显示指定行数，本例会显示文件的头19行的内容。</span></code></pre><h3 id="13、tail命令（显示文件后面内容）"><a href="#13、tail命令（显示文件后面内容）" class="headerlink" title="13、tail命令（显示文件后面内容）"></a>13、tail命令（显示文件后面内容）</h3><h5 id="13-1-显示文件最后10行内容"><a href="#13-1-显示文件最后10行内容" class="headerlink" title="13. 1 显示文件最后10行内容"></a>13. 1 显示文件最后10行内容</h5><pre><code class="hljs properties"><span class="hljs-comment"># tail  /etc/httpd/conf/httpd.conf</span><span class="hljs-attr">功能：默认显示指定文件的末尾10行的内容。</span></code></pre><h5 id="13-2-显示文件最后n行内容"><a href="#13-2-显示文件最后n行内容" class="headerlink" title="13.2 显示文件最后n行内容"></a>13.2 显示文件最后n行内容</h5><pre><code class="hljs properties"><span class="hljs-comment"># tail  -n 12  /etc/httpd/conf/httpd.conf</span><span class="hljs-attr">功能：参数-n设置显示指定行数；</span>          <span class="hljs-attr">本例会显示文件的末尾12行的内容。</span></code></pre><h1 id="二、用户、组管理命令"><a href="#二、用户、组管理命令" class="headerlink" title="二、用户、组管理命令"></a>二、<strong>用户、组管理命令</strong></h1><ul><li>Linux采用<strong>组</strong>来组织和管理用户</li><li>在Linux中每个用户有唯一的用户标识符UID，该UID是一个无符号整数。</li><li>同时每个用户也必须<strong>至少属于一个组</strong>，也有组标识符GID。</li><li>其中UID与GID独立编号。</li></ul><h3 id="1-groupadd命令"><a href="#1-groupadd命令" class="headerlink" title="1. groupadd命令"></a>1. groupadd命令</h3><h5 id="1-1-创建组账户"><a href="#1-1-创建组账户" class="headerlink" title="1.1 创建组账户"></a>1.1 创建组账户</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# groupadd  mygroup1</span><span class="hljs-attr">功能：创建一个新组mygroup1，其GID号为已存在GID号的下一个顺序编号。</span><span class="hljs-attr">说明：创建一个组的同时会在/etc/group文件中为该组增加相应的一行，用来记录该组的名称、GID号及成员等信息。</span></code></pre><h5 id="1-2-创建组账户并设置其GID号"><a href="#1-2-创建组账户并设置其GID号" class="headerlink" title="1.2 创建组账户并设置其GID号"></a>1.2 创建组账户并设置其GID号</h5><pre><code class="hljs properties"><span class="hljs-comment"># groupadd  -g 5000  mygroup2</span><span class="hljs-attr">功能：创建一个新组mygroup2，并指定其GID号为5000，其中-g用来设置用户的主要组，每个用户都有一个主要组。</span></code></pre><h3 id="2、useradd命令"><a href="#2、useradd命令" class="headerlink" title="2、useradd命令"></a>2、useradd命令</h3><h5 id="2-1-创建用户账号"><a href="#2-1-创建用户账号" class="headerlink" title="2.1 创建用户账号"></a>2.1 创建用户账号</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# useradd  user1</span><span class="hljs-attr">功能：创建一个用户user1，同时在/etc/passwd文件和/etc/shadow文件增加一行，并自动为用户创建相应的主目录：/home/user1。</span><span class="hljs-attr">说明：/etc/passwd文件记录了系统中每个用户的用户名、UID号、GID号、主目录、shell等信息。</span><span class="hljs-attr">注意：用户的口令原来也存放在此文件中，现在为了保证安全采用了影子口令文件/etc/shadow来保存每个用户的口令。</span></code></pre><h5 id="2-2-创建用户账号并设置相应属性值"><a href="#2-2-创建用户账号并设置相应属性值" class="headerlink" title="2.2 创建用户账号并设置相应属性值"></a>2.2 创建用户账号并设置相应属性值</h5><pre><code class="hljs properties"><span class="hljs-comment"># useradd  -u 600  -g mygroup1  -G mygroup2  -d  /home/student1  s1</span><span class="hljs-attr">功能：创建用户s1，其中参数</span><span class="hljs-attr">-u指定UID号为600；</span><span class="hljs-attr">-g指定用户的主要组为mygroup1；</span><span class="hljs-attr">-G指定用户的附加组为mygroup2，每个用户可以有多个附加组；</span><span class="hljs-meta">-d</span> <span class="hljs-string">指定用户的主目录为/home/student1。</span></code></pre><h3 id="3、userdel命令"><a href="#3、userdel命令" class="headerlink" title="3、userdel命令"></a>3、userdel命令</h3><h5 id="3-1-删除用户"><a href="#3-1-删除用户" class="headerlink" title="3.1 删除用户"></a>3.1 删除用户</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# userdel  user1</span><span class="hljs-attr">功能：删除指定的用户user1。</span></code></pre><h5 id="3-2-删除用户的同时删除其主目录"><a href="#3-2-删除用户的同时删除其主目录" class="headerlink" title="3.2 删除用户的同时删除其主目录"></a>3.2 删除用户的同时删除其主目录</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# userdel  -r  user2</span><span class="hljs-attr">功能：删除指定的用户user2，同时删除其主目录。</span></code></pre><h3 id="4、groupdel命令（删除指定的组）"><a href="#4、groupdel命令（删除指定的组）" class="headerlink" title="4、groupdel命令（删除指定的组）"></a>4、groupdel命令（删除指定的组）</h3><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# groupdel mygroup2</span><span class="hljs-attr">功能：删除指定的组</span><span class="hljs-attr">注意：当某个组是某现有用户的主要组时，则不能被删除。</span></code></pre><h3 id="5、passwd命令"><a href="#5、passwd命令" class="headerlink" title="5、passwd命令"></a>5、passwd命令</h3><h5 id="5-1-改变口令"><a href="#5-1-改变口令" class="headerlink" title="5.1 改变口令"></a>5.1 改变口令</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# passwd</span><span class="hljs-attr">Changing</span> <span class="hljs-string">password for user user1.</span><span class="hljs-attr">Changing</span> <span class="hljs-string">password for user1</span><span class="hljs-meta">(current)</span> <span class="hljs-string">Unix password:</span><span class="hljs-attr">New</span> <span class="hljs-string">Unix password:</span><span class="hljs-attr">BAD</span> <span class="hljs-string">PASSWORD: it is too simplistic/systematic</span><span class="hljs-attr">New</span> <span class="hljs-string">Unix password:</span><span class="hljs-attr">BAD</span> <span class="hljs-string">PASSWORD: is too similar to the old one</span><span class="hljs-attr">New</span> <span class="hljs-string">Unix password:</span><span class="hljs-attr">Retype</span> <span class="hljs-string">new Unix password:</span><span class="hljs-attr">passwd</span>: <span class="hljs-string">all authentication tokens updated successfully.</span><span class="hljs-attr">功能：普通用户只可以修改自己的口令</span></code></pre><h5 id="5-2-禁止用户登录"><a href="#5-2-禁止用户登录" class="headerlink" title="5.2 禁止用户登录"></a>5.2 禁止用户登录</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# passwd  -l  user1</span><span class="hljs-attr">Locking</span> <span class="hljs-string">password for user user1.</span><span class="hljs-attr">passwd</span>: <span class="hljs-string">Success</span><span class="hljs-meta">功能：参数-l</span> <span class="hljs-string">可以给指定的用户user1加锁，即禁止该用户登录。</span></code></pre><h5 id="5-3-恢复用户登录"><a href="#5-3-恢复用户登录" class="headerlink" title="5.3 恢复用户登录"></a>5.3 恢复用户登录</h5><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# passwd  –u  user1</span><span class="hljs-attr">Unlocking</span> <span class="hljs-string">password for user user1.</span><span class="hljs-attr">passwd</span>: <span class="hljs-string">Success.</span><span class="hljs-meta">功能：参数-u</span> <span class="hljs-string">可以给指定的用户user1解锁，即恢复该用户登录。</span></code></pre><h5 id="5-4-删除用户口令"><a href="#5-4-删除用户口令" class="headerlink" title="5.4 删除用户口令"></a>5.4 删除用户口令</h5><pre><code class="hljs properties"> <span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# passwd  -d  user1</span><span class="hljs-attr">Removing</span> <span class="hljs-string">password for user user1.</span><span class="hljs-attr">passwd</span>: <span class="hljs-string">Success</span><span class="hljs-meta">功能：参数-d</span> <span class="hljs-string">可以删除指定的用户user1口令，即以user1登录时无需口令。</span></code></pre><h3 id="6、usermod命令（修改用户的UID和组）"><a href="#6、usermod命令（修改用户的UID和组）" class="headerlink" title="6、usermod命令（修改用户的UID和组）"></a>6、usermod命令（修改用户的UID和组）</h3><pre><code class="hljs properties"><span class="hljs-comment"># usermod  -u  601  -g 501  s1</span><span class="hljs-attr">功能：将（已存在的）用户s1的UID号修改为601、主要组修改为501。</span></code></pre><h3 id="7、id命令（显示UID，GID）"><a href="#7、id命令（显示UID，GID）" class="headerlink" title="7、id命令（显示UID，GID）"></a>7、id命令（显示UID，GID）</h3><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# id  user1</span><span class="hljs-attr">uid</span>=<span class="hljs-string">501(user1) gid=501(user1) groups=501(user1)</span><span class="hljs-attr">功能：显示用户的UID、GID及所属的组信息。</span></code></pre><h1 id="三、文件属性操作命令"><a href="#三、文件属性操作命令" class="headerlink" title="三、文件属性操作命令"></a>三、文件属性操作命令</h1><h3 id="1、chown命令（改变文件的属主）"><a href="#1、chown命令（改变文件的属主）" class="headerlink" title="1、chown命令（改变文件的属主）"></a>1、chown命令（改变文件的属主）</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）chown示例一——改变文件的属主</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# chown  user1  hello.txt</span><span class="hljs-attr">功能：将指定文件hello.txt的属主（所有者）改为user1。</span><span class="hljs-attr">（2）chown示例二——递归改变文件的属主</span><span class="hljs-comment"># chown  -R  user1  mydir</span><span class="hljs-attr">功能：参数-R，表示递归，即可以深入到指定目录中的每一层，将所有子目录和文件的属主（所有者）改为指定的用户；本例中会将mydir目录中所有子目录和文件的属主设定为user1。</span></code></pre><h3 id="2、chgrp命令（改变文件的属组）"><a href="#2、chgrp命令（改变文件的属组）" class="headerlink" title="2、chgrp命令（改变文件的属组）"></a>2、chgrp命令（改变文件的属组）</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）chgrp示例一——改变文件的属组</span><span class="hljs-comment"># chgrp  mygroup1  hello.txt</span><span class="hljs-attr">功能：将指定文件hello.txt的属组改为mygroup1。</span><span class="hljs-attr">（2）chgrp示例二——递归改变文件的属组</span><span class="hljs-comment"># chgrp  -R  mygroup1  mydir</span><span class="hljs-attr">功能：参数-R，表示递归，即可以深入到指定目录中的每一层，将所有子目录和文件的属组改为指定的组；本例中会将mydir目录中所有子目录和文件的属组设定为mygroup1。</span></code></pre><h3 id="3、chmod命令（更改文件的属主权限）"><a href="#3、chmod命令（更改文件的属主权限）" class="headerlink" title="3、chmod命令（更改文件的属主权限）"></a>3、chmod命令（更改文件的属主权限）</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）chmod示例一——字母方式</span>   <span class="hljs-attr">图中字母u针对属主、g针对属组、o针对其他用户、a针对所有用户；</span>    =表示赋予（设置）指定权限，要注意它会覆盖原权限，+表示在原有权限的基础上增加指定权限，-表示在原有权限的基础上去掉指定权限；    <span class="hljs-attr">r、w、x三种权限，既可以单独使用也可以组合使用</span><span class="hljs-comment"># chmod  u+x  host.conf</span><span class="hljs-attr">功能：为文件host.conf的属主增加执行权限。</span><span class="hljs-comment"># chmod  g-w,o=x  host.conf</span><span class="hljs-attr">功能：将文件host.conf的属组去掉写权限，同时将其他用户设置为只有执行权限，而文件属主的权限不变。</span><span class="hljs-attr">（2）chmod示例二——数字方式</span><span class="hljs-attr">chmod的数字使用方式，使用起来也是很方便的，关键是一个数制转换的问题。</span><span class="hljs-attr">这种方式是先将每个权限位化成二进制数，其中如果某权限位是“-”则用0来表示，否则用1来表示；接着，将这9列权限分为三组（每三位一组），再将每组化成一个八进制数。</span><span class="hljs-attr">例如，某文件有如下权限rwxrw-r--，则转换为二进制数为111110100，再化为八进制数则为764；反之，当看到八进制数764时也应该很快转化为相应权限。</span><span class="hljs-comment"># chmod  764  host.conf</span><span class="hljs-attr">功能：将文件host.conf的权限设置为：</span><span class="hljs-attr">属主拥有全部权限；</span><span class="hljs-attr">属组拥有读写权限；</span><span class="hljs-attr">其他用户拥有只读权限。</span></code></pre><h1 id="四、i节点及其相关命令"><a href="#四、i节点及其相关命令" class="headerlink" title="四、i节点及其相关命令"></a>四、i节点及其相关命令</h1><h3 id="1、ln命令（建立硬连接）"><a href="#1、ln命令（建立硬连接）" class="headerlink" title="1、ln命令（建立硬连接）"></a>1、ln命令（建立硬连接）</h3><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ln  myfile  myfile.hlink</span><span class="hljs-attr">功能：为文件myfile创建名为myfile.hlink的硬连接。</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ls  -il</span><span class="hljs-attr">180590</span> <span class="hljs-string">-rw-rw-r--  2  user1 user1   12 Aug 17 12:14 myfile</span><span class="hljs-attr">180590</span> <span class="hljs-string">-rw-rw-r--  2  user1 user1   12 Aug 17 12:14 myfile.hlink</span><span class="hljs-meta">说明：通过ls</span>  <span class="hljs-string">–il 命令可以看出myfile与myfile.hlink的i节点号（最左面的数）是一样的，即硬连接与原文件共用同一个i节点，请注意两个文件的连接数（位于长格式列表中权限位与属主之间的数）都增加了1变成2了。</span></code></pre><h3 id="2、建立符号连接"><a href="#2、建立符号连接" class="headerlink" title="2、建立符号连接"></a>2、建立符号连接</h3><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ln  -s  myfile  myfile.slink</span><span class="hljs-attr">功能：为文件myfile创建名为myfile.slink的符号连接。</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# ls  -li</span><span class="hljs-attr">180590</span> <span class="hljs-string">-rw-rw-r--    2  user1 user1   12 Aug 17 12:14 myfile</span><span class="hljs-attr">180590</span> <span class="hljs-string">-rw-rw-r--    2  user1 user1   12 Aug 17 12:14 myfile.hlink</span><span class="hljs-attr">180606</span> <span class="hljs-string">lrwxrwxrwx  1  user1 user1    6 Aug 21 06:21 myfile.slink -&gt; myfile</span><span class="hljs-attr">说明：硬链接若一个inode号对应多个文件名时，则称之为硬链接。硬链接具有以下几个特性：文件拥有相同的inode号和数据块；只能对已存在的文件创建硬链接；不能跨越文件系统创建硬链接；不能堆目录创建硬链接；删除一个硬链接文件不影响其他相同inode号的文件。软链接在Linux中，若文件的数据块中存放的内容是另一文件的路径名，则称之为软连接。软链接类似于Windows系统下的快捷方式。软连接有自己的inode号和用户数据块。为此，软链接避免了硬链接的诸多限制，软链接主要具有以下特点：软链接有自己的文件属性及权限等；可以对不存在的文件或目录创建软链接；软链接可以跨越文件系统创建；删除软链接时不会影响被指向的文件；若原文件被删除时，相关软链接文件被称为死链接（当该路路劲的文件重新创建时，死链接可以恢复正常）。</span></code></pre><h1 id="五、查找命令"><a href="#五、查找命令" class="headerlink" title="五、查找命令"></a>五、查找命令</h1><h3 id="1、which命令-显示命令的绝对路径"><a href="#1、which命令-显示命令的绝对路径" class="headerlink" title="1、which命令(显示命令的绝对路径)"></a>1、which命令(显示命令的绝对路径)</h3><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# which cp</span><span class="hljs-attr">/bin/cp</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# which updatedb</span><span class="hljs-attr">/usr/bin/updatedb</span><span class="hljs-attr">功能：显示命令的绝对路径。</span><span class="hljs-attr">注意：该命令只能在命令搜索路径指定的目录中去查找命令或程序。</span></code></pre><h3 id="2、whereis命令（查询指定命令所在目录以及帮助文档所在目录）"><a href="#2、whereis命令（查询指定命令所在目录以及帮助文档所在目录）" class="headerlink" title="2、whereis命令（查询指定命令所在目录以及帮助文档所在目录）"></a>2、whereis命令（查询指定命令所在目录以及帮助文档所在目录）</h3><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# whereis ln</span><span class="hljs-attr">ln</span>: <span class="hljs-string">/bin/ln /usr/share/man/man1/ln.1.gz /usr/share/man/man1p/ln.1p.gz</span><span class="hljs-attr">功能：查询指定命令所在目录以及帮助文档所在目录。</span></code></pre><h3 id="3、find命令（按照文件的名称，大小，类型，修改时间，权限查找文件）"><a href="#3、find命令（按照文件的名称，大小，类型，修改时间，权限查找文件）" class="headerlink" title="3、find命令（按照文件的名称，大小，类型，修改时间，权限查找文件）"></a>3、find命令（按照文件的名称，大小，类型，修改时间，权限查找文件）</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）find示例一——按文件名查找</span><span class="hljs-comment"># find  /  -name  &quot;dhcpd*&quot;</span><span class="hljs-attr">功能：参数-name指明按文件名进行查找，即从/目录开始查找以dhcpd开头的所有文件。</span><span class="hljs-attr">（2）find示例二——按文件大小查找</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# find  /etc  -size  8</span><span class="hljs-attr">功能：从/etc下开始查找大小为8块的文件，此处默认512字节为1块。若认为块大小为1k，则应写为8k。</span>   <span class="hljs-attr">其它可以使用的单位有c（字节）、w（双字节）、M（兆字节）和G（吉字节）。</span><span class="hljs-attr">（3）find示例三——按文件类型查找</span><span class="hljs-comment"># find  /var  -type d  -print</span><span class="hljs-attr">功能：从/var目录下开始查找类型为目录的文件，其中参数-print是显示到屏幕上的意思，经常省略。</span><span class="hljs-attr">（4）find示例四——按文件的修改时间查找</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# find  .  -cmin -5</span><span class="hljs-attr">功能：从当前目录下查找5分钟之内修改过的文件。</span>   <span class="hljs-meta">如果把“-5”改为</span> <span class="hljs-string">“+5”，则表示查找5分钟以前修改过的文件。不带“+”或“-”，则认为整5分钟。</span>  <span class="hljs-attr">如果把时间单位改为天，则使用参数“-ctime”，请看示例：</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# find  .  -ctime -5</span><span class="hljs-attr">（5）find示例五——按文件的权限查找</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]#find  mytmp  -perm  755</span><span class="hljs-attr">功能：查找mytmp目录下的权限恰为755的文件。</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]#find  mytmp  -perm  +755</span><span class="hljs-attr">功能：查找mytmp目录下的满足755中任何一种权限的文件，即符合任何一个指定的权限位即可。</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]#find  mytmp  -perm  -755</span><span class="hljs-attr">功能：查找mytmp目录下的权限至少满足755的文件，即指定的所有权限位必须符合才算满足查询条件。</span></code></pre><h1 id="六、文件内容操作命令"><a href="#六、文件内容操作命令" class="headerlink" title="六、文件内容操作命令"></a>六、文件内容操作命令</h1><h3 id="1、grep命令-在指定的文件查找特定的字符串"><a href="#1、grep命令-在指定的文件查找特定的字符串" class="headerlink" title="1、grep命令(在指定的文件查找特定的字符串)"></a>1、grep命令(在指定的文件查找特定的字符串)</h3><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# grep  &quot;bind&quot;  host.conf</span><span class="hljs-attr">功能：在文件host.conf中查找包含字符串“bind”行。</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# grep  &quot;network&quot;  /etc/*.conf</span><span class="hljs-attr">功能：利用通配符可在多个文件中查找包含特定的字符串的行。本例会在/etc下扩展名为.conf文件中查找包含字符串“network”的行。</span><span class="hljs-attr">（2）grep示例二——查找不包含指定字符串的行</span><span class="hljs-comment"># grep  -v  &quot;network&quot;  /etc/nsswitch.conf</span><span class="hljs-attr">功能：查找/etc/nsswitch.conf文件中不包含字符串“network”的行</span></code></pre><h3 id="2、wc命令（字数统计）"><a href="#2、wc命令（字数统计）" class="headerlink" title="2、wc命令（字数统计）"></a>2、wc命令（字数统计）</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）wc示例一——统计指定文件的行数、单词数和字符数</span><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# wc  /etc/nsswitch.conf</span>  <span class="hljs-attr">63</span>  <span class="hljs-string">272  1718  /etc/nsswitch.conf</span><span class="hljs-attr">功能：统计出文件/etc/nsswitch.conf共有63行、272个单词、1718个字符。</span><span class="hljs-attr">（2）wc示例二——参数使用</span><span class="hljs-comment"># wc  -l  /etc/nsswitch.conf</span><span class="hljs-attr">63</span>  <span class="hljs-string">/etc/nsswitch.conf</span><span class="hljs-attr">功能：参数-l的功能可统计出指定文件的行数。另外，利用参数-w统计单词，利用-c统计字符数。</span></code></pre><h3 id="3、sort命令-以行为单位按序输出"><a href="#3、sort命令-以行为单位按序输出" class="headerlink" title="3、sort命令(以行为单位按序输出)"></a>3、sort命令(以行为单位按序输出)</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）sort示例一——按正序输出</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# sort  mytest</span><span class="hljs-attr">功能：将指定文件以行为单位按正序输出。</span><span class="hljs-attr">（2）sort示例二——按逆序输出</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# sort  -r  mytest</span><span class="hljs-attr">功能：将指定文件以行为单位按逆序输出。</span></code></pre><h3 id="4、diff命令-比较不同"><a href="#4、diff命令-比较不同" class="headerlink" title="4、diff命令(比较不同)"></a>4、diff命令(比较不同)</h3><pre><code class="hljs properties"><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# diff  test  mytest</span><span class="hljs-attr">功能：比较文件test与mytest是否相同，将不同之处输出到屏幕上。</span></code></pre><h3 id="5、cut命令-按特定的分隔符提取指定的字段"><a href="#5、cut命令-按特定的分隔符提取指定的字段" class="headerlink" title="5、cut命令(按特定的分隔符提取指定的字段)"></a>5、cut命令(<strong>按特定的分隔符提取指定的字段</strong>)</h3><pre><code class="hljs properties"> <span class="hljs-attr">cut命令是一个文本提取工具，它以行为单位，将每行看作一条记录，而字段之间的分隔符可以灵活地定义。</span><span class="hljs-attr">（1）cut示例一——按特定的分隔符提取指定的字段</span><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# cut  -d:  -f1  /etc/passwd</span><span class="hljs-attr">功能：参数-d用来定义字段之间的分隔符，参数-f指定提取第几个字段；本例为提取/etc/passwd文件中以“：”为分隔符的第1个字段。</span></code></pre><h1 id="七、压缩与打包命令"><a href="#七、压缩与打包命令" class="headerlink" title="七、压缩与打包命令"></a>七、压缩与打包命令</h1><h3 id="1-tar命令-打包-备份"><a href="#1-tar命令-打包-备份" class="headerlink" title="1. tar命令(打包/备份)"></a>1. tar命令(打包/备份)</h3><pre><code class="hljs properties"> <span class="hljs-attr">tar命令是经典的备份/还原命令，几乎所有最新的软件包都是通过tar包发布的。</span><span class="hljs-attr">（1）tar命令示例一——打包（备份）</span><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# tar  -cvf  myetc.tar  /etc</span><span class="hljs-meta">功能：</span>  <span class="hljs-string">参数-c的功能是打包（创建），</span>           <span class="hljs-attr">参数-v是显示处理过程，</span>           <span class="hljs-attr">参数-f是用来指定文档名；</span><span class="hljs-attr">本例的功能是：将目录/etc打包为一个名为myetc.tar的文档。</span><span class="hljs-attr">（2）tar命令示例二——打包（备份）并压缩</span><span class="hljs-comment"># tar  -zcvf  myetc.tar.gz  /etc</span><span class="hljs-attr">功能：将目录/etc打包并压缩为一个名为myetc.tar.gz的文档。</span><span class="hljs-attr">说明：其中参数-z是调用gzip命令来压缩，扩展名为gz，</span><span class="hljs-attr">参数-Z是调用compress命令来压缩，扩展名为Z，</span><span class="hljs-attr">参数-j是调用bzip2命令来压缩，扩展名为bz2。</span></code></pre><h1 id="八、网卡配置命令"><a href="#八、网卡配置命令" class="headerlink" title="八、网卡配置命令"></a>八、网卡配置命令</h1><h3 id="1-ipconfig"><a href="#1-ipconfig" class="headerlink" title="1. ipconfig"></a>1. ipconfig</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）ifconfig命令示例一——显示接口（网卡）配置参数</span><span class="hljs-meta">[root@server2</span> <span class="hljs-string">~]# ifconfig</span><span class="hljs-attr">功能：显示网卡参数的配置情况，包括IP地址、子网掩码、广播地址等。</span><span class="hljs-attr">（2）ifconfig命令示例二——设置接口（网卡）配置参数</span><span class="hljs-comment"># ifconfig  eth0  10.22.1.103  netmask  255.255.255.0</span><span class="hljs-attr">功能：设置网卡eth0的IP地址为10.22.1.103、掩码为255.255.255.0。</span><span class="hljs-attr">说明：eth0是系统中第1块以太网卡的名称，eth1是系统中第2块以太网卡的名称，以此类推。lo是环回测试网卡的名称。</span><span class="hljs-attr">（3）ifconfig命令示例三——禁用某块网卡</span><span class="hljs-meta">[root@server2</span> <span class="hljs-string">~]# ifconfig  eth0  down</span><span class="hljs-attr">功能：禁用网卡eth0。</span><span class="hljs-attr">说明：此时再用不带参数的ifconfig命令是不能显示eth0的信息的，需要加上参数“-a”才可显示被禁用的网卡信息。</span><span class="hljs-attr">（4）ifconfig命令示例四——激活某块网卡</span><span class="hljs-meta">[root@server2</span> <span class="hljs-string">~]# ifconfig  eth0  up</span><span class="hljs-attr">功能：激活网卡eth0。</span></code></pre><h1 id="九、rpm命令（执行安装包）"><a href="#九、rpm命令（执行安装包）" class="headerlink" title="九、rpm命令（执行安装包）"></a>九、rpm命令（执行安装包）</h1><pre><code class="hljs properties"><span class="hljs-attr">（1）rpm命令示例一——查询系统中安装的软件包</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# rpm -qa</span><span class="hljs-attr">功能：查询系统中安装的软件包列表，其中参数-q的功能是“查询”，参数-a的功能是“所有的”。</span><span class="hljs-attr">（2）rpm命令示例二——查询软件包中文件清单</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]#rpm  -ql  php</span><span class="hljs-attr">功能：查询已安装的软件包php中的文件列表，其中参数-l的功能是“列出指定软件包中的文件”。</span><span class="hljs-attr">（3）rpm命令示例三——卸载指定的软件包</span><span class="hljs-meta">[root@yxy</span> <span class="hljs-string">~]# rpm  -e  php</span><span class="hljs-attr">功能：卸载已安装的软件包php，参数-e的功能是“卸载”。</span><span class="hljs-attr">说明：请注意执行上述命令时，采用的身份是不同的，普通用户只能执行查询操作。</span><span class="hljs-attr">（4）rpm命令示例四——安装软件包</span><span class="hljs-comment"># rpm  -ivh  php-4.3.9-3.1-i386.rpm</span><span class="hljs-attr">功能：安装软件包php，</span>   <span class="hljs-attr">参数-i的功能是“安装”，</span>   <span class="hljs-attr">参数-v的功能是“显示处理过程”，</span>   <span class="hljs-attr">参数-h的功能是显示“#”来表示进度。</span><span class="hljs-attr">（5）rpm命令示例五——强制安装软件包</span><span class="hljs-comment"># rpm  -ivh  --force  php-4.3.9-3.1-i386.rpm</span><span class="hljs-attr">功能：强制安装软件包php，参数--force表示强制的意思。</span><span class="hljs-attr">说明：如果要安装的软件的版本比较低或该软件包在系统中已存在，系统会给出提示并拒绝安装，此时可以加上参数—force来进行强制安装。</span><span class="hljs-attr">（6）rpm命令示例五——忽略依赖关系安装软件包</span><span class="hljs-comment"># rpm  -ivh  --nodeps  php-4.3.9-3.1-i386.rpm</span><span class="hljs-attr">功能：安装软件包php时忽略与其它软件包的依赖关系，参数--nodeps表示忽略依赖关系。</span><span class="hljs-attr">说明：在安装或卸载软件时经常会遇到提示“该软件包与某某软件包存在依赖关系”，只有加上参数--nodeps忽略掉依赖关系才能进行安装或卸载。</span><span class="hljs-attr">（7）卸载</span>             <span class="hljs-meta">首先通过</span>  <span class="hljs-string">rpm -q &lt;关键字&gt; 可以查询到rpm包的名字</span><span class="hljs-meta">然后</span> <span class="hljs-string">调用 rpm -e &lt;包的名字&gt; 删除特定rpm包</span><span class="hljs-meta">如果遇到依赖，无法删除，使用</span> <span class="hljs-string">rpm -e --nodeps &lt;包的名字&gt; 不检查依赖，直接删除rpm包</span></code></pre><h1 id="十、其他安装方式"><a href="#十、其他安装方式" class="headerlink" title="十、其他安装方式"></a>十、其他安装方式</h1><pre><code class="hljs properties"><span class="hljs-attr">yum安装</span>       <span class="hljs-attr">yum</span> <span class="hljs-string">install 软件名字</span>       <span class="hljs-attr">yum</span> <span class="hljs-string">install yum-fastestmirror</span>       <span class="hljs-attr">yum</span> <span class="hljs-string">remove</span>              <span class="hljs-attr">源码安装</span><span class="hljs-attr">./configure</span>            <span class="hljs-attr">make</span>            <span class="hljs-attr">make</span> <span class="hljs-string">install</span>            <span class="hljs-attr">make</span> <span class="hljs-string">clean与make distclean</span></code></pre><h1 id="十一、查看进程命令"><a href="#十一、查看进程命令" class="headerlink" title="十一、查看进程命令"></a>十一、查看进程命令</h1><h3 id="1-ps命令（查看进程）"><a href="#1-ps命令（查看进程）" class="headerlink" title="1. ps命令（查看进程）"></a>1. ps命令（查看进程）</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）ps命令示例一——不带参数</span><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# ps</span><span class="hljs-attr">功能：查询在当前控制台上运行的进程。</span><span class="hljs-attr">（2）ps命令示例二——查看所有进程</span><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# ps  -aux</span><span class="hljs-attr">功能：查询系统中所有运行的进程，包括后台进程，其中参数a是所有进程，参数x包括不占用控制台的进程，参数u显示用户。</span><span class="hljs-attr">（3）ps命令示例三——查看所有进程</span><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# ps  -ef</span><span class="hljs-attr">功能：查询系统中所有运行的进程，包括后台进程，而且可以显示出每个进程的父进程号。</span></code></pre><h3 id="2-pstree命令（树状格式显示进程）"><a href="#2-pstree命令（树状格式显示进程）" class="headerlink" title="2. pstree命令（树状格式显示进程）"></a>2. pstree命令（树状格式显示进程）</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）pstree命令示例一——树状格式显示进程列表</span><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# pstree</span><span class="hljs-attr">功能：以树状格式显示系统的进程列表。</span><span class="hljs-attr">（2）pstree命令示例二——带进程号的树状格式显示进程列表</span><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# pstree  -p</span><span class="hljs-attr">功能：以树状格式显示系统的进程列表，并标识出每个进程的进程号</span></code></pre><h3 id="3-top命令-动态显示进程"><a href="#3-top命令-动态显示进程" class="headerlink" title="3. top命令(动态显示进程)"></a>3. top命令(动态显示进程)</h3><pre><code class="hljs properties"><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# top</span><span class="hljs-attr">功能：动态地显示系统中的进程。</span></code></pre><h3 id="4-kill命令（杀死进程）"><a href="#4-kill命令（杀死进程）" class="headerlink" title="4. kill命令（杀死进程）"></a>4. kill命令（杀死进程）</h3><pre><code class="hljs properties"><span class="hljs-attr">（1）kill命令示例一——杀掉指定进程</span><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# kill  3029</span><span class="hljs-attr">功能：kill命令可以杀掉一个进程，当然普通用户只能杀掉自己的进程。</span><span class="hljs-attr">说明：上述命令中3029是进程号；一般在执行kill命令之前，先用ps或pstree来查询一下将要被杀掉的进程的进程号。</span><span class="hljs-attr">（2）kill命令示例二——强制杀掉指定进程</span><span class="hljs-meta">[user1@server2</span> <span class="hljs-string">~]# kill  -9  3029</span><span class="hljs-attr">功能：强制终止3029号进程的运行，其中参数-9代表强制的意思。</span><span class="hljs-attr">说明：实际上kill命令是向该进程发送信号，该进程接到信号后决定是否停止运行，有些守护进程必须要收到参数9才终止运行。</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基本命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot</title>
    <link href="/2020/10/15/Springboot/"/>
    <url>/2020/10/15/Springboot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot学习"><a href="#SpringBoot学习" class="headerlink" title="SpringBoot学习"></a>SpringBoot学习</h1><h1 id="一、SpringBoot入门"><a href="#一、SpringBoot入门" class="headerlink" title="一、SpringBoot入门"></a>一、SpringBoot入门</h1><h2 id="1、SpringBoot简介"><a href="#1、SpringBoot简介" class="headerlink" title="1、SpringBoot简介"></a>1、SpringBoot简介</h2><p>简化新Spring应用的初始搭建以及开发过程 </p><h2 id="2、SpringBoot-HelloWorld"><a href="#2、SpringBoot-HelloWorld" class="headerlink" title="2、SpringBoot HelloWorld"></a>2、SpringBoot HelloWorld</h2><p>一个功能:</p><p>浏览器发送Web请求，服务器接收并处理，响应HelloWorld字符串;</p><ul><li><p>1、创建一个maven工程(jar)</p></li><li><p>2、导入Springboot依赖</p><pre><code class="hljs java">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.3.4.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li><li><p>3、编写一个主程序</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(HelloWorld.class,args);    &#125;&#125;</code></pre></li><li><p>4、编写相关的controller和service</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@ResponseBody</span>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;return world!&quot;</span>;    &#125;&#125;</code></pre></li><li><p>5、完成应用</p></li><li><p>6、简化部署</p></li></ul><pre><code class="hljs java">&lt;build&gt;       &lt;plugins&gt;           &lt;plugin&gt;               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;               &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;           &lt;/plugin&gt;       &lt;/plugins&gt;   &lt;/build&gt;</code></pre><p>将这个应用打包成jar包，直接使用java -jar命令进行执行;</p><h2 id="3、HelloWorld探究"><a href="#3、HelloWorld探究" class="headerlink" title="3、HelloWorld探究"></a>3、HelloWorld探究</h2><p><strong>@SpringBootApplication</strong>: SpringBoot应用标注在某个类上的说明是SpringBoot的主配置类, SpringBoot就会运行这个类的main方法启动SpringBoot; </p><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-meta">@Inherited</span><span class="hljs-meta">@SpringBootConfiguration</span><span class="hljs-meta">@EnableAutoConfiguration</span><span class="hljs-meta">@ComponentScan</span></code></pre><p><strong>@SpringBootConfiguration</strong>: Spring Boot的配置类 </p><p>​                 <strong>@Configuration</strong> : <strong>@Componet</strong></p><p><strong>@EnableAutoConfiguration</strong>: 开启自动配置功能; </p><h2 id="4、使用Spring-Initializer快速创建Spring-Boot项目"><a href="#4、使用Spring-Initializer快速创建Spring-Boot项目" class="headerlink" title="4、使用Spring Initializer快速创建Spring Boot项目"></a>4、使用Spring Initializer快速创建Spring Boot项目</h2><p>@RestController = @Controller + @ResponseBody</p><p>resources</p><ul><li><p>static: 保存静态资源 js img css</p></li><li><p>templates 保存所有的模板页面 默认使用嵌入式的tomcat 不支持jsp页面 可以使用模板引擎(freemaker thymeleaf)</p></li><li><p>application.properties 应用配置文件 </p></li></ul><h1 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h1><h2 id="1、配置文件"><a href="#1、配置文件" class="headerlink" title="1、配置文件"></a>1、配置文件</h2><ul><li>application.properties</li></ul><pre><code class="hljs xml">server.port=8081</code></pre><ul><li>application.yml</li></ul><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>   <span class="hljs-string">port:8081</span></code></pre><ul><li>application.xml</li></ul><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8081<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span></code></pre><h2 id="2、yml语法"><a href="#2、yml语法" class="headerlink" title="2、yml语法"></a>2、yml语法</h2><h3 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h3><p>k: v: 表示一对键值对 以空格的缩进来控制层级 大小写敏感</p><h3 id="2-值的写法"><a href="#2-值的写法" class="headerlink" title="2.值的写法"></a>2.值的写法</h3><ul><li><p>数字, 字符串, 布尔</p></li><li><p>对象, Map </p></li></ul><pre><code class="hljs yaml"><span class="hljs-attr">friends:</span>  <span class="hljs-string">lastNmae:zhangsan</span>  <span class="hljs-string">age:20</span></code></pre><p>行内写法</p><pre><code class="hljs yaml"><span class="hljs-attr">friends:</span> &#123;<span class="hljs-attr">lastName:</span> <span class="hljs-string">zhangsan</span>, <span class="hljs-attr">age :</span> <span class="hljs-number">18</span>&#125;</code></pre><ul><li>数组 List, Set</li></ul><pre><code class="hljs yaml"><span class="hljs-attr">pets:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">cat</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">dog</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">pig</span></code></pre><p>行内写法:</p><pre><code class="hljs yaml"><span class="hljs-attr">pets:</span> [<span class="hljs-string">cat</span>,<span class="hljs-string">dog</span>,<span class="hljs-string">pig</span>]</code></pre><h3 id="3-配置文件注入"><a href="#3-配置文件注入" class="headerlink" title="3.配置文件注入"></a>3.配置文件注入</h3><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><ul><li>@Validated 开启数据校验 例如 @Email 可以检测数据是不是电子邮件</li></ul><h3 id="4-PropertySource-amp-ImportResource"><a href="#4-PropertySource-amp-ImportResource" class="headerlink" title="4.@PropertySource &amp; @ImportResource"></a>4.@PropertySource &amp; @ImportResource</h3><p>@PropertySource: 加载指定的配置文件</p><pre><code class="hljs java"><span class="hljs-meta">@ImportResource(value = &#123;&quot;classpath:person.properties&quot;&#125;)</span></code></pre><p>@ImportResource: 导入Spring的配置文件，让配置文件里的内容生效 标记在主配置类上</p><pre><code class="hljs java"><span class="hljs-meta">@ImportResource(locations = &#123;classpath:beans.xml&#125;)</span></code></pre><h3 id="5-可以在配置文件中加入占位符"><a href="#5-可以在配置文件中加入占位符" class="headerlink" title="5.可以在配置文件中加入占位符"></a>5.可以在配置文件中加入占位符</h3><ul><li>随机数</li></ul><p>random.value ${random.dog}</p><ul><li>占位符获取之前配置的值，如果没有可以用冒号（：）　指定默认值</li></ul><h2 id="3、Profile"><a href="#3、Profile" class="headerlink" title="3、Profile"></a>3、Profile</h2><h4 id="1-多Profile文件"><a href="#1-多Profile文件" class="headerlink" title="1.多Profile文件"></a>1.多Profile文件</h4><p>我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties/yml</p><p>默认使用application.properties</p><h4 id="2-yml支持多文档块方式"><a href="#2-yml支持多文档块方式" class="headerlink" title="2.yml支持多文档块方式"></a>2.yml支持多文档块方式</h4><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><span class="hljs-attr">spring:</span> <span class="hljs-attr">profiles:</span> <span class="hljs-attr">active:</span> <span class="hljs-string">dev/prod</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><span class="hljs-attr">spring:</span> <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><span class="hljs-meta">---</span><span class="hljs-attr">server:</span> <span class="hljs-attr">port:</span> <span class="hljs-number">8084</span><span class="hljs-attr">spring:</span> <span class="hljs-attr">profiles:</span> <span class="hljs-string">prod</span></code></pre><h4 id="3-指定激活配置文件"><a href="#3-指定激活配置文件" class="headerlink" title="3.指定激活配置文件"></a>3.指定激活配置文件</h4><ul><li><p>properties文件中加入 spring.profiles.active=dev </p></li><li><p>可以在命令行中加入 –spring.profiles.active=dev </p></li><li><p>虚拟机参数 Dspring.profiles.active=dev 优先</p></li></ul><h2 id="4、配置文件扫描位置"><a href="#4、配置文件扫描位置" class="headerlink" title="4、配置文件扫描位置"></a>4、配置文件扫描位置</h2><p><img src="/SpringbootImage/20201015_01.png" alt="内部配置文件加载顺序"></p><p>SpringBoot 会从这四个位置文件中全部加载文件 互补配置</p><h2 id="5、外部配置加载顺序"><a href="#5、外部配置加载顺序" class="headerlink" title="5、外部配置加载顺序"></a>5、外部配置加载顺序</h2><p><img src="/SpringbootImage/20201015_02.png" alt="外部配置文件加载顺序"></p><h2 id="6、自动配置加载原理"><a href="#6、自动配置加载原理" class="headerlink" title="6、自动配置加载原理"></a>6、自动配置加载原理</h2><h3 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h3><ul><li>1.springBoot启动会加载大量的自动配置类</li><li>2.我们看我们需要的功能有没有Springboot默认写好的自动配置类</li><li>3.我们再来看这个自动配置类到底配置了哪些组件</li><li>4.给容器配置组件的时候会从properties中获取某些属性，我们就可以在配置文件中指定这些属性的值</li></ul><h3 id="2、细节"><a href="#2、细节" class="headerlink" title="2、细节"></a>2、细节</h3><p>@<strong>Conditional</strong> 派生详解</p><p>作用: 必须是@conditional指定的条件成立，才给容器添加组件，配置配的里面所有内容才生效</p><p><img src="/SpringbootImage/20201015_03.png" alt="细节"></p><p>==自动配置类必须在一定的条件下才能生效==</p><p>可以在配置文件下输入 debug=true属性 在控制台生成自动打印开启了哪些自动配置报告</p><h1 id="三、SpringBoot与日志"><a href="#三、SpringBoot与日志" class="headerlink" title="三、SpringBoot与日志"></a>三、SpringBoot与日志</h1><h2 id="1、选择工具"><a href="#1、选择工具" class="headerlink" title="1、选择工具"></a>1、选择工具</h2><p>SLF4j和Logback</p><h2 id="2、SLF4j的使用"><a href="#2、SLF4j的使用" class="headerlink" title="2、SLF4j的使用"></a>2、SLF4j的使用</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> </span>&#123;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;    Logger logger = LoggerFactory.getLogger(HelloWorld.class);    logger.info(<span class="hljs-string">&quot;Hello World&quot;</span>);  &#125;&#125;</code></pre><p>如何让系统中所有日志都统一到slf4j</p><ul><li>将系统中其他日志框架排除出去</li><li>用中间包替换原有的日志框架</li><li>导入slf4j的实现</li></ul><h2 id="3、日志使用"><a href="#3、日志使用" class="headerlink" title="3、日志使用"></a>3、日志使用</h2><p>SpringBoot已经默认配置好了日志</p><pre><code class="hljs java">Logger logger = LoggerFactory.getLogger(getClass());        <span class="hljs-comment">//日志级别由高到低 error warn info debug trace</span>        logger.trace(<span class="hljs-string">&quot;这是trace日志&quot;</span>);        logger.debug(<span class="hljs-string">&quot;这是debug信息&quot;</span>);        <span class="hljs-comment">//springboot默认输出 info级别以上的</span>        logger.info(<span class="hljs-string">&quot;这是info日志&quot;</span>);        logger.warn(<span class="hljs-string">&quot;这是warn信息&quot;</span>);        logger.error(<span class="hljs-string">&quot;这是error日志&quot;</span>);</code></pre><pre><code class="hljs yml"><span class="hljs-string">日志输出格式:</span> <span class="hljs-string">%d表示日期时间</span><span class="hljs-string">%thread表示线程名</span><span class="hljs-string">%-5level</span> <span class="hljs-string">级别</span><span class="hljs-string">%logger&#123;50&#125;</span> <span class="hljs-string">logger名字字符数量</span><span class="hljs-string">%msg</span> <span class="hljs-string">日志消息</span><span class="hljs-string">%n换行</span><span class="hljs-string">--&gt;</span><span class="hljs-string">logging.pattern.file=%d&#123;yyyy-mm-dd&#125;</span> <span class="hljs-string">==</span> [<span class="hljs-string">%thread</span>] <span class="hljs-string">===</span> <span class="hljs-string">%-5level</span> <span class="hljs-string">===</span> <span class="hljs-string">%logger&#123;50&#125;</span> <span class="hljs-string">===</span> <span class="hljs-string">%msg%n</span> <span class="hljs-string">文件内</span><span class="hljs-string">logging.pattern.console=%d&#123;yyyy-mm-dd&#125;</span> <span class="hljs-string">==</span> [<span class="hljs-string">%thread</span>] <span class="hljs-string">===</span> <span class="hljs-string">%-5level</span> <span class="hljs-string">===</span> <span class="hljs-string">%logger&#123;50&#125;</span> <span class="hljs-string">===</span> <span class="hljs-string">%msg%n</span> <span class="hljs-string">控制台</span></code></pre><h2 id="4、日志指定配置"><a href="#4、日志指定配置" class="headerlink" title="4、日志指定配置"></a>4、日志指定配置</h2><p>在类路径下放上每个日志框架自己的配置文件，SpringBoot就不会采用它的默认框架了</p><p>Logback 可以采用logback.xml 或者 logback-spring.xml</p><p>推荐使用logback-spring.xml 可以使用springboot中的Profile </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">SpringProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;XXX&quot;</span>&gt;</span>XXXXX<span class="hljs-tag">&lt;/<span class="hljs-name">SpringProfile</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">SpringProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;!XXX&quot;</span>&gt;</span>XXXXX<span class="hljs-tag">&lt;/<span class="hljs-name">SpringProfile</span>&gt;</span></code></pre><h1 id="四、SpringBoot与Web开发"><a href="#四、SpringBoot与Web开发" class="headerlink" title="四、SpringBoot与Web开发"></a>四、SpringBoot与Web开发</h1><h2 id="1-SpringBoot对静态资源的映射规则"><a href="#1-SpringBoot对静态资源的映射规则" class="headerlink" title="1.SpringBoot对静态资源的映射规则"></a>1.SpringBoot对静态资源的映射规则</h2><p>1.所有/webjars/**，都去classpath:/META-INF/resources/webjars/找资源</p><p>webjars: 以jar包的方式引入静态资源</p><p><img src="/SpringbootImage/20201015_04.png" alt="静态资源"></p><p>local host:8080/webjars/jquery/3.4.1/jquery.js</p><p>2./** 访问当前项目的任何资源”</p><pre><code class="hljs java">classpath:/META-INF/resources/classpath:/resources/classpath:/<span class="hljs-keyword">static</span>/classpath:/<span class="hljs-keyword">public</span>//</code></pre><h2 id="2-模板引擎"><a href="#2-模板引擎" class="headerlink" title="2.模板引擎"></a>2.模板引擎</h2><p>SpringBoot 推荐 thymeleaf</p><p>首先引入thymeleaf</p><pre><code class="hljs java">&lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;       &lt;/dependency&gt;</code></pre><pre><code class="hljs dust"><span class="xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns:th</span>=<span class="hljs-string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>成功<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">th:text</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;hello&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></code></pre><ul><li>thymeleaf语法规则</li></ul><p><img src="/SpringbootImage/20201015_05.png"></p><h2 id="3、扩展SpringMVC"><a href="#3、扩展SpringMVC" class="headerlink" title="3、扩展SpringMVC"></a>3、扩展SpringMVC</h2><p>例如 SpringMVC的xml配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">view-names</span>=<span class="hljs-string">&quot;success&quot;</span>/&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/hello&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span></code></pre><p>我们可以编写一个SpringBoot配置类</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//浏览器发送atguigu请求，来到success页面</span>        registry.addViewController(<span class="hljs-string">&quot;/atguigu&quot;</span>).setViewName(<span class="hljs-string">&quot;success&quot;</span>);    &#125;&#125;</code></pre><h2 id="4、RestfulCRUD"><a href="#4、RestfulCRUD" class="headerlink" title="4、RestfulCRUD"></a>4、RestfulCRUD</h2><p>1.默认访问首页</p><p>可以用</p><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&#123;&quot;/&quot;,&quot;/index.html&quot;&#125;)</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;    &#125;</code></pre><p>或者</p><p>添加视图映射 在MyMvcConfig里添加</p><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addViewControllers</span><span class="hljs-params">(ViewControllerRegistry registry)</span> </span>&#123;        <span class="hljs-comment">//浏览器发送atguigu请求，来到success页面</span>        registry.addViewController(<span class="hljs-string">&quot;/atguigu&quot;</span>).setViewName(<span class="hljs-string">&quot;success&quot;</span>);        registry.addViewController(<span class="hljs-string">&quot;/&quot;</span>).setViewName(<span class="hljs-string">&quot;login&quot;</span>);    &#125;&#125;</code></pre><p>==registry.addViewController(“/“).setViewName(“login”);==</p><p>2.页面切换语言</p><p>在SpringMVC中需要使用ResourceBundleMessageSource管理国际化资源文件</p><p>在页面fmt:message取出国际化内容</p><p>springboot中</p><p><img src="/SpringbootImage/20201016_01.png"></p><p>3.去页面获取国际化值</p><p>国际化Locale(区域信息对象); LocaleResolver</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;        String l = request.getParameter(<span class="hljs-string">&quot;l&quot;</span>);        Locale locale = Locale.getDefault();        <span class="hljs-keyword">if</span>(!StringUtils.isEmpty(l))&#123;            String[] split = l.split(<span class="hljs-string">&quot;_&quot;</span>);            locale = <span class="hljs-keyword">new</span> Locale(split[<span class="hljs-number">0</span>],split[<span class="hljs-number">1</span>]);        &#125;        <span class="hljs-keyword">return</span> locale;    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Bean</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyLocaleResolver();    &#125;</code></pre><p>4.登录拦截器检查</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginHandlerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        Object user = request.getSession().getAttribute(<span class="hljs-string">&quot;loginUser&quot;</span>);        <span class="hljs-keyword">if</span>(user == <span class="hljs-keyword">null</span>)&#123;            request.setAttribute(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;请先登录&quot;</span>);            request.getRequestDispatcher(<span class="hljs-string">&quot;/index.html&quot;</span>).forward(request,response);            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;        &#125;    &#125;</code></pre><pre><code class="hljs java"><span class="hljs-meta">@Override</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;       registry.addInterceptor(<span class="hljs-keyword">new</span> LoginHandlerInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)               .excludePathPatterns(<span class="hljs-string">&quot;/index.html&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-string">&quot;/user/login&quot;</span>,<span class="hljs-string">&quot;/static/**&quot;</span>,<span class="hljs-string">&quot;/webjars/**&quot;</span>,<span class="hljs-string">&quot;/assert/**&quot;</span>);   &#125;</code></pre><p>5.员工列表功能</p><p>restfulcrud 满足rest风格</p><p>URI: /资源名称/资源标识 HTTP请求方式区分对资源的CRUD操作</p><table><thead><tr><th></th><th>普通CRUD</th><th>RestfulCRUD</th></tr></thead><tbody><tr><td>查询</td><td>getEmp</td><td>emp—-GET</td></tr><tr><td>添加</td><td>addEmp?xxx</td><td>emp—-POST</td></tr><tr><td>修改</td><td>updateEmp?id=xxx%xxx</td><td>emp/{id}—-PUT</td></tr><tr><td>删除</td><td>deleteEmp?id=1</td><td>emp/{id}—-DELETE</td></tr></tbody></table><p>实验的请求架构</p><table><thead><tr><th></th><th>请求RUI</th><th>请求方式</th></tr></thead><tbody><tr><td>查询所有员工</td><td>emps</td><td>GET</td></tr><tr><td>查询某个员工</td><td>emps/{id}</td><td>GET</td></tr><tr><td>添加页面</td><td>emp</td><td>GET</td></tr><tr><td>添加员工</td><td>emp</td><td>POST</td></tr><tr><td>修改页面</td><td>emps/{id}</td><td>GET</td></tr><tr><td>修改员工</td><td>emp</td><td>PUT</td></tr><tr><td>删除员工</td><td>emp/{id}</td><td>DELETE</td></tr></tbody></table><p>6.错误处理机制</p><h1 id="五、Docker"><a href="#五、Docker" class="headerlink" title="五、Docker"></a>五、Docker</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p><strong>Docker</strong>是一个开源的应用容器引擎</p><p>让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的<a href="https://baike.baidu.com/item/Linux">Linux</a>机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。</p><h2 id="2、核心概念"><a href="#2、核心概念" class="headerlink" title="2、核心概念"></a>2、核心概念</h2><p>docker主机(Host)：安装了Docker程序的机器(Docker直接安装在操作系统上)</p><p>docker客户端(Client)：连接docker主机进行操作</p><p>docker仓库(Registry)：用来保存各种打包好的软件镜像</p><p>docker镜像(Images)：软件打包好的镜像 放在docker仓库中</p><p>docker容器(Container)：镜像启动后的实例为一个容器</p>]]></content>
    
    
    <categories>
      
      <category>Java框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2020/10/01/JVM/"/>
    <url>/2020/10/01/JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM学习"><a href="#JVM学习" class="headerlink" title="JVM学习"></a>JVM学习</h1><p>本篇文章根据<a href="https://www.bilibili.com/video/BV1yE411Z7AP">解密JVM</a>教学视频学习时，所做的笔记。</p><h3 id="一、什么是JVM"><a href="#一、什么是JVM" class="headerlink" title="一、什么是JVM"></a>一、什么是JVM</h3><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine，JAVA程序的<strong>运行环境</strong>（JAVA二进制字节码的运行环境）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>一次编写，到处运行</li><li>自动内存管理，垃圾回收机制</li><li>数组下标越界检查</li></ul><h2 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h2><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><strong>整体架构</strong></h3><p><img src="/ArticleImage/20201002_01.png" alt="整体架构">  </p><h3 id="1、程序计数器"><a href="#1、程序计数器" class="headerlink" title="1、程序计数器"></a>1、程序计数器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>用于保存JVM中下一条所要执行的指令的地址</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>线程私有 (每个线程都有自己的程序计数器)</p><ul><li>CPU会为每个线程分配时间片，当当前线程的时间片使用完以后，CPU就会去执行另一个线程中的代码</li><li>程序计数器是<strong>每个线程</strong>所<strong>私有</strong>的，当另一个线程的时间片用完，又返回来执行当前线程的代码时，通过程序计数器可以知道应该执行哪一句指令</li></ul></li><li><p>不会存在内存溢出</p></li></ul><h3 id="2、虚拟机栈"><a href="#2、虚拟机栈" class="headerlink" title="2、虚拟机栈"></a>2、虚拟机栈</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>每个<strong>线程</strong>运行需要的内存空间，称为<strong>虚拟机栈</strong></li><li>每个栈由多个<strong>栈帧</strong>组成，对应着每次调用方法时所占用的内存</li><li>每个线程只能有<strong>一个活动栈帧</strong>，对应着<strong>当前正在执行的方法</strong></li></ul><h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;method1();&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;method2(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">method2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c = a + b;<span class="hljs-keyword">return</span> c;&#125;&#125;</code></pre><p>每执行一个方法就把栈帧压入栈中，执行完后就弹出栈</p><p><img src="/ArticleImage/20201003_01.png" alt="虚拟栈演示"> </p><h4 id="问题辨析"><a href="#问题辨析" class="headerlink" title="问题辨析"></a>问题辨析</h4><ol><li><p>垃圾回收是否涉及栈内存?</p><p><strong>不需要</strong>。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。</p></li><li><p>栈内存分配越大越好吗?</p><p>不是。因为<strong>物理内存是一定的</strong>，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。</p></li><li><p>方法内的局部变量是否安全</p><p>如果方法内<strong>局部变量没有逃离方法的作用范围</strong>，则是<strong>线程安全</strong>的</p><p>如果如果<strong>局部变量引用了对象</strong>，并<strong>逃离了方法的作用范围</strong>，则需要考虑线程安全问题</p></li></ol><h4 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h4><p><strong>Java.lang.stackOverflowError</strong> 栈内存溢出</p><h4 id="发生原因"><a href="#发生原因" class="headerlink" title="发生原因"></a>发生原因</h4><ul><li>栈帧<strong>过多</strong>导致栈内存溢出(例如递归)</li><li>栈帧<strong>过大</strong></li></ul><h4 id="线程运行诊断"><a href="#线程运行诊断" class="headerlink" title="线程运行诊断"></a>线程运行诊断</h4><p>CPU占用过高</p><ul><li>Linux环境下运行某些程序的时候，可能导致CPU的占用过高，这时需要定位占用CPU过高的线程<ul><li><strong>top</strong>命令，查看是哪个<strong>进程</strong>占用CPU过高</li><li><strong>ps H -eo pid, tid（线程id）, %cpu | grep 刚才通过top查到的进程号</strong> 通过ps命令进一步查看是哪个线程占用CPU过高</li><li><strong>jstack 进程id</strong> 通过查看进程中的线程的nid，刚才通过ps命令看到的tid来<strong>对比定位</strong>，注意jstack查找出的线程id是<strong>16进制的</strong>，<strong>需要转换</strong></li></ul></li></ul><h3 id="3、本地方法栈"><a href="#3、本地方法栈" class="headerlink" title="3、本地方法栈"></a>3、本地方法栈</h3><p>一些带有<strong>native关键字</strong>的方法就是需要JAVA去调用本地的C或者C++方法，因为JAVA有时候没法直接和操作系统底层交互，所以需要用到本地方法</p><h3 id="4、堆"><a href="#4、堆" class="headerlink" title="4、堆"></a>4、堆</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>通过new关键字<strong>创建的对象</strong>都会被放在堆内存</p><h4 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h4><p><strong>java.lang.OutofMemoryError</strong> ：java heap space. 堆内存溢出</p><h4 id="堆内存诊断"><a href="#堆内存诊断" class="headerlink" title="堆内存诊断"></a>堆内存诊断</h4><ul><li><p><strong>jps</strong></p></li><li><p><strong>jmap</strong></p></li><li><p><strong>jconsole</strong></p></li><li><p><strong>jvirsalvm</strong></p></li></ul><h3 id="5、方法区"><a href="#5、方法区" class="headerlink" title="5、方法区"></a>5、方法区</h3><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><img src="/ArticleImage/20201004_01.png" alt="方法区结构"></p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><ul><li>1.8以前会导致<strong>永久代</strong>内存溢出 <strong>java.lang.OutofMemoryError</strong> ：PermGen space</li><li>1.8以后会导致<strong>元空间</strong>内存溢出 <strong>java.lang.OutofMemoryError</strong> ：Metaspace </li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>二进制字节码的组成：类的基本信息、常量池、类的方法定义（包含了虚拟机指令）</p><p><strong>通过反编译来查看类的信息</strong></p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><ul><li><p>常量池</p><ul><li>就是一张表（如上图中的constant pool），虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量信息</li></ul></li><li><p>运行时常量池</p><ul><li><p>常量池是*.class文件中的，当该<strong>类被加载以后</strong>，它的常量池信息就会<strong>放入运行时常量池</strong>，并把里面的<strong>符号地址变为真实地址</strong>常量池与串池的关系</p><h5 id="串池StringTable"><a href="#串池StringTable" class="headerlink" title="串池StringTable"></a><strong>串池</strong>StringTable</h5><p><strong>特征</strong></p><ul><li>常量池中的字符串仅是符号，只有<strong>在被用到时才会转化为对象</strong></li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong>(1.8)</li><li>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></li><li>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</li><li><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</li></ul><p>用来放字符串对象且里面的<strong>元素不重复</strong></p></li></ul></li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">&quot;a&quot;</span>; String b = <span class="hljs-string">&quot;b&quot;</span>;String ab = <span class="hljs-string">&quot;ab&quot;</span>;&#125;&#125;</code></pre><p>常量池中的信息，都会被加载到运行时常量池中，但这是a b ab 仅是常量池中的符号，<strong>还没有成为java字符串</strong></p><pre><code class="hljs java">0: ldc           #2                  // String a<span class="hljs-number">2</span>: astore_13: ldc           #3                  // String b<span class="hljs-number">5</span>: astore_26: ldc           #4                  // String ab<span class="hljs-number">8</span>: astore_3<span class="hljs-number">9</span>: <span class="hljs-keyword">return</span></code></pre><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">&quot;a&quot;</span>;String b = <span class="hljs-string">&quot;b&quot;</span>;String ab = <span class="hljs-string">&quot;ab&quot;</span>;<span class="hljs-comment">//拼接字符串对象来创建新的字符串</span>String ab2 = a+b; &#125;&#125;</code></pre><p>反编译后的结果</p><pre><code class="hljs java"> Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span>         0: ldc           #2                  // String a         <span class="hljs-number">2</span>: astore_1         3: ldc           #3                  // String b         <span class="hljs-number">5</span>: astore_2         6: ldc           #4                  // String ab         <span class="hljs-number">8</span>: astore_3         9: new           #5                  // class java/lang/StringBuilder        <span class="hljs-number">12</span>: dup        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        <span class="hljs-number">16</span>: aload_1        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        <span class="hljs-number">20</span>: aload_2        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-number">29</span>: <span class="hljs-keyword">return</span></code></pre><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：StringBuilder().append(“a”).append(“b”).toString()</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><pre><code class="hljs java">String ab = <span class="hljs-string">&quot;ab&quot;</span>;String ab2 = a+b;<span class="hljs-comment">//结果为false,因为ab是存在于串池之中，ab2是由StringBuffer的toString方法所返回的一个对象，存在于堆内存之中</span>System.out.println(ab == ab2);</code></pre><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringTableStudy</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;String a = <span class="hljs-string">&quot;a&quot;</span>;String b = <span class="hljs-string">&quot;b&quot;</span>;String ab = <span class="hljs-string">&quot;ab&quot;</span>;String ab2 = a+b;<span class="hljs-comment">//使用拼接字符串的方法创建字符串</span>String ab3 = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span>;&#125;&#125;</code></pre><p>反编译后的结果</p><pre><code class="hljs java">  Code:      stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">6</span>, args_size=<span class="hljs-number">1</span>         0: ldc           #2                  // String a         <span class="hljs-number">2</span>: astore_1         3: ldc           #3                  // String b         <span class="hljs-number">5</span>: astore_2         6: ldc           #4                  // String ab         <span class="hljs-number">8</span>: astore_3         9: new           #5                  // class java/lang/StringBuilder        <span class="hljs-number">12</span>: dup        13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V        <span class="hljs-number">16</span>: aload_1        17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        <span class="hljs-number">20</span>: aload_2        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;        <span class="hljs-number">27</span>: astore        <span class="hljs-number">4</span>        <span class="hljs-comment">//ab3初始化时直接从串池中获取字符串</span>        29: ldc           #4                  // String ab        <span class="hljs-number">31</span>: astore        <span class="hljs-number">5</span>        <span class="hljs-number">33</span>: <span class="hljs-keyword">return</span></code></pre><ul><li>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</li><li>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuffer来创建</strong></li></ul><h5 id="intern方法-1-8"><a href="#intern方法-1-8" class="headerlink" title="intern方法 1.8"></a>intern方法 1.8</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时如果调用intern方法成功，堆内存与串池中的字符串对象是同一个对象；如果失败，则不是同一个对象</p><p><strong>例1</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);<span class="hljs-comment">//调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span>String st2 = str.intern();<span class="hljs-comment">//给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;<span class="hljs-comment">//因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span>System.out.println(str == st2);System.out.println(str == str3);&#125;&#125;</code></pre><p><strong>例2</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">//此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中</span>String str3 = <span class="hljs-string">&quot;ab&quot;</span>;        <span class="hljs-comment">//&quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中</span>String str = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;b&quot;</span>);        <span class="hljs-comment">//此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot;</span>String str2 = str.intern();        <span class="hljs-comment">//false</span>System.out.println(str == str2);        <span class="hljs-comment">//false</span>System.out.println(str == str3);        <span class="hljs-comment">//true</span>System.out.println(str2 == str3);&#125;&#125;</code></pre><p>​        </p><h5 id="intern方法-1-6"><a href="#intern方法-1-6" class="headerlink" title="intern方法 1.6"></a>intern方法 1.6</h5><p>调用字符串对象的intern方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，会将该字符串对象复制一份，再放入到串池中</li><li>如果有该字符串对象，则放入失败</li></ul><p>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</p><p><strong>注意</strong>：此时无论调用intern方法成功与否，串池中的字符串对象和堆内存中的字符串对象<strong>都不是同一个对象</strong></p><h4 id="StringTable-垃圾回收"><a href="#StringTable-垃圾回收" class="headerlink" title="StringTable 垃圾回收"></a>StringTable 垃圾回收</h4><p>StringTable在内存紧张时，会发生垃圾回收</p><h4 id="StringTable-调优"><a href="#StringTable-调优" class="headerlink" title="StringTable 调优"></a>StringTable 调优</h4><ul><li>因为StringTable是由HashTable实现的，所以可以<strong>适当增加HashTable桶的个数</strong>，来减少字符串放入串池所需要的时间</li></ul><pre><code class="hljs java">-XX:StringTableSize=xxxx</code></pre><ul><li><p>考虑是否需要将字符串对象入池</p><p>可以通过<strong>intern方法减少重复入池</strong></p></li></ul><h3 id="6、直接内存-Direct-Memory"><a href="#6、直接内存-Direct-Memory" class="headerlink" title="6、直接内存(Direct Memory)"></a>6、直接内存(Direct Memory)</h3><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="文件读写流程"><a href="#文件读写流程" class="headerlink" title="文件读写流程"></a>文件读写流程</h4><p><img src="/ArticleImage/20201008_01.png" alt="文件读写流程"></p><p><strong>使用了DirectBuffer</strong></p><p><img src="/ArticleImage/20201008_02.png" alt="DirectBuffer**"></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="释放原理"><a href="#释放原理" class="headerlink" title="释放原理"></a>释放原理</h4><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory</strong>来手动释放</p><p>通过</p><pre><code class="hljs java"><span class="hljs-comment">//通过ByteBuffer申请1M的直接内存</span>ByteBuffer byteBuffer = ByteBuffer.allocateDirect(_1M);</code></pre><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><h5 id="直接内存的回收机制总结"><a href="#直接内存的回收机制总结" class="headerlink" title="直接内存的回收机制总结"></a>直接内存的回收机制总结</h5><ul><li>使用了Unsafe类来完成直接内存的分配回收，回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><p>-XX:DisableExplicitGC 禁用显式的垃圾回收 加上这条指令会使System.gc() 无效</p><h2 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h2><h3 id="1、如何判断对象可以回收"><a href="#1、如何判断对象可以回收" class="headerlink" title="1、如何判断对象可以回收"></a>1、如何判断对象可以回收</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>弊端：循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h4><p><img src="/ArticleImage/20201009_01.png" alt="五种引用类型"></p><h5 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h5><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h5><p>当GC Root指向软引用对象时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong></p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><p><strong>软引用的使用</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);&#125;&#125;</code></pre><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> _4M = <span class="hljs-number">4</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<span class="hljs-comment">//使用引用队列，用于移除引用为空的软引用对象</span>ReferenceQueue&lt;<span class="hljs-keyword">byte</span>[]&gt; queue = <span class="hljs-keyword">new</span> ReferenceQueue&lt;&gt;();<span class="hljs-comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span>List&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt; ref= <span class="hljs-keyword">new</span> SoftReference&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[_4M]);<span class="hljs-comment">//遍历引用队列，如果有元素，则移除</span>Reference&lt;? extends <span class="hljs-keyword">byte</span>[]&gt; poll = queue.poll();<span class="hljs-keyword">while</span>(poll != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">//引用队列不为空，则从集合中移除该元素</span>list.remove(poll);<span class="hljs-comment">//移动到引用队列中的下一个元素</span>poll = queue.poll();&#125;&#125;&#125;</code></pre><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><h5 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a><strong>虚引用</strong></h5><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h5><p>所有的类都继承自Object类，Object类有一个finalize方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入饮用队列中，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize方法。调用以后，该对象就可以被垃圾回收了</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize方法。调用以后，该对象就可以被垃圾回收了</li></ul><h5 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h5><ul><li>软引用和弱引用<strong>可以配合</strong>引用队列<ul><li>在<strong>弱引用</strong>和<strong>虚引用</strong>所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象</li></ul></li><li>虚引用和终结器引用<strong>必须配合</strong>引用队列<ul><li>虚引用和终结器引用在使用时会关联一个引用队列</li></ul></li></ul><h3 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a>2、垃圾回收算法</h3><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4><p><img src="/ArticleImage/20201012_01.png" alt="标记清楚算法"></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存</li></ul><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢</p><h4 id="标记-整理"><a href="#标记-整理" class="headerlink" title="标记-整理"></a>标记-整理</h4><p><img src="/ArticleImage/20201012_02.png" alt="标记整理算法"></p><p><strong>标记-整理</strong> 会将不被GC Root引用的对象回收，清楚其占用的内存空间。然后整理剩余的对象，可以有效避免因内存碎片而导致的问题，但是因为整体需要消耗一定的时间，所以效率较低</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><img src="/ArticleImage/20201012_03.png" alt="复制算法1"></p><p><img src="/ArticleImage/20201012_04.png" alt="复制算法2"></p><p><img src="/ArticleImage/20201012_05.png" alt="复制算法3"></p><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会占用双倍的内存空间。</p><h3 id="3、分代回收"><a href="#3、分代回收" class="headerlink" title="3、分代回收"></a>3、分代回收</h3><p><img src="/ArticleImage/20201012_06.png" alt="分代回收1"></p><h4 id="回收流程"><a href="#回收流程" class="headerlink" title="回收流程"></a>回收流程</h4><p>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中</p><p><img src="/ArticleImage/20201012_07.png" alt="分代回收2"></p><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时的回收叫做 <strong>Minor GC</strong></p><p>Minor GC 会将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>，再<strong>交换两个幸存区</strong></p><p><img src="/ArticleImage/20201012_08.png" alt="分代回收3"></p><p><img src="/ArticleImage/20201012_09.png" alt="分代回收4"></p><p><img src="/ArticleImage/20201012_10.png" alt="分代回收5"></p><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>stop the world</strong>， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><img src="/ArticleImage/20201012_11.png" alt="分代回收6"></p><p>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会被<strong>放入老年代</strong>中</p><p><img src="/ArticleImage/20201012_12.png" alt="分代回收7"></p><p>如果新生代老年代中的内存都满了，就会先出法Minor Gc，再触发<strong>Full GC</strong>，扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><h5 id="垃圾回收步骤"><a href="#垃圾回收步骤" class="headerlink" title="垃圾回收步骤"></a>垃圾回收步骤</h5><ul><li>对象首先分配在伊甸园区域</li><li>新生代空间不足，触发minor gc，伊甸园和from存活的对象使用copy复制到to中，存活的对象年龄+1 ，并且交换from to</li><li>minor gc 会引发<strong>stop the world</strong>，暂停其他用户的线程，等垃圾回收结束后，用户线程才恢复运行</li><li>当对象寿命超过阈值时，会晋升老年代，最大寿命是<strong>15</strong>次(4bit)</li><li>当minor gc回收后，老年代空间不足时，会触发一次full gc     <strong>STW</strong>的时间更长</li></ul><h4 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h4><p><img src="/ArticleImage/20201012_13.png" alt="相关vm参数"></p><h4 id="GC-分析"><a href="#GC-分析" class="headerlink" title="GC 分析"></a>GC 分析</h4><h5 id="大对象处理策略"><a href="#大对象处理策略" class="headerlink" title="大对象处理策略"></a>大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="线程内存溢出"><a href="#线程内存溢出" class="headerlink" title="线程内存溢出"></a>线程内存溢出</h5><p>某个线程的内存溢出了而抛异常（out of memory），不会让其他的线程结束运行</p><p>这是因为当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>进程依然正常</strong></p><h3 id="4、垃圾回收器"><a href="#4、垃圾回收器" class="headerlink" title="4、垃圾回收器"></a>4、垃圾回收器</h3><h4 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h4><p><strong>并行收集</strong>：指多条垃圾收集线程并行工作，但此时<strong>用户线程仍处于等待状态</strong>。</p><p><strong>并发收集</strong>：指用户线程与垃圾收集线程<strong>同时工作</strong>（不一定是并行的可能会交替执行）。<strong>用户程序在继续运行</strong>，而垃圾收集程序运行在另一个CPU上</p><p><strong>吞吐量</strong>：即CPU用于<strong>运行用户代码的时间</strong>与CPU<strong>总消耗时间</strong>的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p><h4 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h4><ul><li><p>单线程</p></li><li><p>内存较小，个人电脑（CPU核数较少）</p><p><img src="/ArticleImage/20201013_01.png" alt="串行"></p></li></ul><p><strong>安全点</strong>：让其他线程都在这个点停下来，以免垃圾回收时移动对象地址，使得其他线程找不到被移动的对象</p><p>因为是串行的，所以只有一个垃圾回收线程。且在该线程执行回收工作时，其他线程进入<strong>阻塞</strong>状态</p><h5 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h5><p>Serial收集器是最基本的、发展历史最悠久的收集器</p><p><strong>特点：</strong>单线程、简单高效（与其他收集器的单线程相比），采用<strong>复制算法</strong>。对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程手机效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）</p><h5 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本</p><p><strong>特点</strong>：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。和Serial收集器一样存在Stop The World问题</p><h5 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h5><p>Serial Old是Serial收集器的老年代版本</p><p><strong>特点</strong>：同样是单线程收集器，采用<strong>标记-整理算法</strong></p><h4 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>单位时间内，STW（stop the world，停掉其他所有工作线程）时间最短</li><li><strong>JDK1.8默认使用</strong>的垃圾回收器</li></ul><p><img src="/ArticleImage/20201013_02.png" alt="吞吐量优先"></p><h5 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h5><p>与吞吐量关系密切，故也称为吞吐量优先收集器</p><p><strong>特点</strong>：属于新生代收集器也是采用<strong>复制算法</strong>的收集器（用到了新生代的幸存区），又是并行的多线程收集器（与ParNew收集器类似）</p><p>该收集器的目标是达到一个可控制的吞吐量。还有一个值得关注的点是：<strong>GC自适应调节策略</strong>（与ParNew收集器最重要的一个区别）</p><p><strong>GC自适应调节策略</strong>：Parallel Scavenge收集器可设置-XX:+UseAdptiveSizePolicy参数。当开关打开时<strong>不需要</strong>手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等，虚拟机会根据系统的运行状况收集性能监控信息，动态设置这些参数以提供最优的停顿时间和最高的吞吐量，这种调节方式称为GC的自适应调节策略。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li><li>XX:GCRatio 直接设置吞吐量的大小</li></ul><h5 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a><strong>Parallel Old 收集器</strong></h5><p>是Parallel Scavenge收集器的老年代版本</p><p><strong>特点</strong>：多线程，采用<strong>标记-整理算法</strong>（老年代没有幸存区）</p><h4 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h4><ul><li>多线程</li><li>堆内存较大，多核CPU</li><li>尽可能让单次STW时间变短（尽量不影响其他线程运行）</li></ul><p><img src="/ArticleImage/20201013_03.png" alt="吞吐量优先"></p><h5 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h5><p>Concurrent Mark Sweep，一种以获取<strong>最短回收停顿时间</strong>为目标的<strong>老年代</strong>收集器</p><p><strong>特点</strong>：基于<strong>标记-清除算法</strong>实现。并发收集、低停顿，但是会产生内存碎片</p><p><strong>应用场景</strong>：适用于注重服务的响应速度，希望系统停顿时间最短，给用户带来更好的体验等场景下。如web程序、b/s服务</p><p><strong>CMS收集器的运行过程分为下列4步：</strong></p><p><strong>初始标记</strong>：标记GC Roots能直接到的对象。速度很快但是<strong>仍存在Stop The World问题</strong></p><p><strong>并发标记</strong>：进行GC Roots Tracing 的过程，找出存活对象且用户线程可并发执行</p><p><strong>重新标记</strong>：为了<strong>修正并发标记期间</strong>因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。仍然存在Stop The World问题</p><p><strong>并发清除</strong>：对标记的对象进行清除回收</p><p>CMS收集器的内存回收过程是与用户线程一起<strong>并发执行</strong>的</p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义</strong>：</h5><p>Garbage First</p><p>JDK 9以后默认使用，而且替代了CMS 收集器</p><p><img src="/ArticleImage/20201013_04.png" alt="G1"></p><h5 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h5><ul><li>同时注重吞吐量和低延迟（响应时间）</li><li>超大堆内存（内存大的），会将堆内存划分为多个<strong>大小相等</strong>的区域</li><li>整体上是<strong>标记-整理</strong>算法，两个区域之间是<strong>复制</strong>算法</li></ul><p><strong>相关参数</strong>：JDK8 并不是默认开启的，所需要参数开启</p><p><img src="/ArticleImage/20201013_05.png" alt="G1"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
